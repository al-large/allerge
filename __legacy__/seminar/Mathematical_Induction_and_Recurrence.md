# 알고리즘 스터디 세미나 - 수학적 귀납법과 점화식

### 신성환 (blueStragglr / Oortcloud1599@gmail.com)

---



####  수학적 귀납법

- 정의

모든 자연수에 정의역 대하여 특정 함수가 성립한다는 것을 증명하는 방법이다.

> 물론, 정의를 확장하여 꼭 자연수 정의역이 아니더라도 사용할 수 있습니다. 

다수의  Dynamic programming은 수학적 귀납법을 바탕으로 논리를 전개하게 된다.

수학적 귀납법의 논리는 다음과 같이 세 가지의 단계로 구성된다. 

1. n=1(혹은 가장 작은 요소)에 대하여, 증명하고자 하는 명제가 성립한다.
2. n에 대해서 증명하고자 하는 명제가 ***성립한다고 가정했을 때***, n+1에 대해서 명제가 성립한다.
3. n=1에 대해 성립하므로, 모든 자연수 n에 대하여 해당 명제가 성립한다.





- 예제

아래와 같은 명제를 수학적 귀납법으로 증명하는 것을 생각 해 보자.

`모든 자연수 n에 대하여, 1부터 n까지 더한 값은 n(n+1)/2 이다.`

아래와 같은 순서로 증명할 수 있다.

1. n=1인 경우, 1부터 1까지의 합은 1이며 1(1+1)/2 = 1이 성립한다.
2. n까지 더한 수의 합이 n(n+1)/2를 만족한다고 가정하자. 이 때, n+1까지의 합은 n까지의 합에 n+1을 더한 것으로써 구할 수 있으므로, 앞의 가정으로부터 n+1까지의 합은 (n+1) + n(n+1)/2 = {2(n+1) + n(n+1)}/2 = (n+2)(n+1)/2가 되어 명제가 성립한다.
3. n=1인 경우에 명제가 성립하고, **일반성을 잃지 않고** n이 성립할 때 n+1에 대하여 해당 명제가 성립하므로, 모든 자연수 n에 대하여 해당 명제가 성립한다. 





- 어디에 쓰나요?

Dynamic programming의 이론적 기반이 되는 것은 물론, 점화식의 일반식이 관계식을 포함하는 모든 수열에 대해 명제로써 성립할 수 있다는 것을 증명하는 논리적 기틀이다. 

자연수 정의역을 가지는 명제에 대하여 "n이 성립할 때"라는 가정을 사용할 수 있으므로 증명이 훨씬 수월해지는 경우가 많다. 

e.g.) Dynamic Programming을 위해 Array에 각 index까지의 최소값을 저장 해 두고, 다음 index의 값을 구하는 것은 유효하다

(https://leetcode.com/problems/house-robber/)



#### 점화식

- 정의와 풀이

점화식이란, 임의의 index들 사이에 **일반성을 잃지 않고** 성립하는 식을 뜻한다. 점화식을 세울 수 있는 경우, 알고리즘의 복잡도가  대부분 O(n)으로 떨어지며 만약 이를 일반식으로써 풀 수 있다면 O(1)까지도 낮출 수 있다. 



- 예제

1. 계단을 한 칸, 혹은 두 칸 올라서 정상에 도착하는 경우의 수를 세는 문제를 생각 해 보자. 특정 칸에 도달하기 이전의 경로는 n-1번째 칸에서 한 칸을 이동하는 경우와 n-2번째 칸에서 두 칸을 이동하는 경우 밖에 없으므로, n번째 칸에 도달하는 경우의 수는 아래와 같이 나타낼 수 있다. 

$$
S(n) = S(n-1) + S(n-2)
$$



2. 특정 정수 Set의 원소를 사용하여 원하는 숫자를 만들 수 있는 모든 Subset의 갯수를 구하는 문제를 생각 해 보자. 이는 윗 문제의 확장으로 생각할 수 있으며, 아래와 같은 식으로써 쓸 수 있다. 

$$
S(n) = min(S(n-a_1), S(n-a_2),...S(n-a_i)) + 1
$$







- 어디다 쓰나요?

점화식 자체가 DP의 이론적 기반이 되므로, 올바른 알고리즘을 구성하는데 도움이 됩니다.

혹시 점화식을 일반식으로 풀어낼 수 있는 경우, 알고리즘의 복잡도가 O(1)로 감소할 수도 있습니다. 



- 점화식의 풀이: 선형대수학적 확장







