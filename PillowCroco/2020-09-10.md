## 9/10/목, 자유주제
자기 하고 싶은 문제 2개씩


```python
# 시간 단위는 분
if 도착시간 > 시작시간 :
    벌금 += math.ceiling((도착시간-시작시간) / 5) * 500

# 'problems' is a list of problems
# 'hosts' is a list of all host who participate in the group study.
# each 'problem' has a 'host' who picks it.

for p in problems:
    for h in hosts:
        if not p.accepted and not p.explained :
            h.벌금 += 2000

        if not p.accepted and p.host is h:
            h.벌금 += 2000
```


- [ ] 감소하는 수
https://www.acmicpc.net/problem/1038
- [ ] QR
https://www.acmicpc.net/problem/2680
- [ ] 기지국 설치
https://programmers.co.kr/learn/courses/30/lessons/12979
- [ ] 경주로 건설
https://programmers.co.kr/learn/courses/30/lessons/67259
- [ ] 79. Word Search
https://leetcode.com/problems/word-search/
- [x] 648. Replace Words
https://leetcode.com/problems/replace-words/


---


### 감소하는 수
https://www.acmicpc.net/problem/1038


```c++
```

---
### QR
https://www.acmicpc.net/problem/2680


```c++
```

---
### 기지국 설치
https://programmers.co.kr/learn/courses/30/lessons/12979


```c++
```

---
### 경주로 건설
https://programmers.co.kr/learn/courses/30/lessons/67259


```c++
```

---
### 79. Word Search
https://leetcode.com/problems/word-search/

- `return` 이 있는 DFS의 경우, 방문 후 함수 진입이 아니라 함수 진입 후 방문으로 짜야 편하다!
- 그 연습을 할 수 있어 좋았다. 전방향 탐색이므로 `ret |= ...` 부분도 좋은 활용이다.
- 근데 다른 사람들이랑 logic이 완전 같은데 TLE가 난다. 아마 TC가 추가된 것 같은데, 다른 사람 코드를 써도 TLE가 나는 것을 보니 다른 방향으로 짜는걸 시도해봐야겠다.

```c++
int d[5] = { -1,0,1,0,-1 };
class Solution {
public:
	bool dfs(int x, int y, int idx, vector<vector<char>>& board, string word) {
		if (word[idx] == '\0')
			return true;
		int n = board.size();
		int m = board[0].size();
		if (x < 0 || x >= n || y < 0 || y >= m)
			return false;
		if (board[x][y] != word[idx])
			return false;

		board[x][y] = '*';

		bool ret = false;
		for (int i = 0; i < 4; i++) {
			int nx = x + d[i], ny = y + d[i + 1];
			ret |= dfs(nx, ny, idx + 1, board, word);
		}

		board[x][y] = word[idx];
		return ret;
	}
	bool exist(vector<vector<char>>& board, string word) {
		if (board.empty() || word.empty())
			return false;
		else if (board[0].empty())
			return false;

		// backtracking은 기본적으로 dfs로 합시다!
		int n = board.size();
		int m = board[0].size();
		for (int x = 0; x < n; x++) {
			for (int y = 0; y < m; y++) {
				if (dfs(x, y, 0, board, word))
					return true;
			}
		}
		return false;
	}
};
```

---
### 648. Replace Words
https://leetcode.com/problems/replace-words/

튜라이 튜라이 외워버렸지 뭐얌

const char쓰다가 string으로 넘어가버렸지뭐얌

하지만 포인터가 좀더 효율적일 것 같다는 생각이 들지 뭐얌


```c++
#include<iostream>
#include<vector>
#include<string>
using namespace std;

class Trie {
public:
	bool isTerminal;
	Trie* child[26];

	Trie() {
		isTerminal = false;
		for (int i = 0; i < 26; i++)
			child[i] = NULL;
	}

	~Trie() {
		for (int i = 0; i < 26; i++)
			delete child[i];
	}

	void insert(string s, int idx = 0) {
		if (s[idx] == '\0')
			isTerminal = true;

		else {
			if (child[s[idx] - 'a'] == NULL)
				child[s[idx] - 'a'] = new Trie();

			child[s[idx] - 'a']->insert(s, idx + 1);
		}
	}

	//// 이게 원형
	//Trie* find(string s, int idx) {
	//	if (s[idx] == '\0' && isTerminal)
	//		return this;
	//	if (child[s[idx] - 'a'] == NULL)
	//		return NULL;

	//	return child[s[idx] - 'a']->find(s, idx + 1);
	//}

	//이건 변형
	void replace(string& s, int idx = 0) {
		if (s[idx] == '\0')
			return;
		else if (isTerminal)
			s = s.substr(0, idx);
		else if (child[s[idx] - 'a'])
			child[s[idx] - 'a']->replace(s, idx + 1);
	}
};

class Solution {
public:
	string replaceWords(vector<string>& dictionary, string sentence) {
		Trie* root = new Trie();
		for (auto s : dictionary)
			root->insert(s);

		int i = 0;
		string ret = "";
		string tmp = "";
		while (sentence[i] != '\0') {
			if (sentence[i] != ' ')
				tmp += sentence[i];
			else if (!tmp.empty()) {
				root->replace(tmp);
				ret += tmp + " ";
				tmp = "";
			}
			i++;
		}

		// for the last word.
		root->replace(tmp);
		ret += tmp;
		return ret;
	}
};
```

---
