## 9/26/토, 자유주제
자기 하고 싶은 문제 2개씩


```python
# 시간 단위는 분
if 도착시간 > 시작시간 :
    벌금 += math.ceiling((도착시간-시작시간) / 5) * 500

# 'problems' is a list of problems
# 'hosts' is a list of all host who participate in the group study.
# each 'problem' has a 'host' who picks it.

for p in problems:
    for h in hosts:
        if not p.accepted and not p.explained :
            h.벌금 += 2000

        if not p.accepted and p.host is h:
            h.벌금 += 2000
```

- [ ] 퍼즐
https://www.acmicpc.net/problem/1525
- [ ] 치즈
https://www.acmicpc.net/problem/2638
- [ ] Philosopher's Walk
https://www.acmicpc.net/problem/14956
- [ ] 원숭이 스포츠
https://www.acmicpc.net/problem/16438
- [ ] Minimum Window Substring
https://leetcode.com/problems/minimum-window-substring/
- [x] Spiral Matrix
https://leetcode.com/problems/spiral-matrix/


---


### 퍼즐
https://www.acmicpc.net/problem/1525


```c++
```

---
### 치즈
https://www.acmicpc.net/problem/2638


```c++
```

---
### Philosopher's Walk
https://www.acmicpc.net/problem/14956


```c++
```

---
### 원숭이 스포츠
https://www.acmicpc.net/problem/16438


```c++
```

---
### Minimum Window Substring
https://leetcode.com/problems/minimum-window-substring/

- TLE.

```c++
#include<map>
#include<iostream>
#include<vector>
#include<string>
#include<utility>
using namespace std;

class Solution {
public:
	bool isContaining(map<char, int> ans, map<char, int> candi) {
		for (auto &it : ans) {
			if (candi[it.first] < it.second)
				return false;
		}
		return true;
	}

	string minWindow(string s, string t) {
		if (t.empty() || s.empty() || s.size() < t.size())
			return "";

		map<char, int> dict_ans, dict_candi;
		for (auto c : t) {
			dict_ans[c]++;
		}

		//from whole string s, shrink!
		//doesn't work for the case: "cabwefgewcwaefgcf", "cae" / expected: "cwae", output: "aefgc"

		int l = 0, r = 0;

		/*
		TLE: "ufhlwmyfgylecixnrvaqmdpoiczivrarxhcvtcaccmgfufunbudnavbkzcsuvvlueppauqcwekdypxnqutfuoienkykgvxaansajiefoolofkbyeudakmgayfkecjheyzehjkpxyangkoerlhrxtyxsfjyhthmrisztdqsdqflcupthxneslcmsnnbgupadibwnrpsjwglqvhzuuenhibzvoaejseoafmpydjhapssnzshtywagybbmefxwlnyqcpofyvhqqadpuklsjnyhpzvvhvrskplmezsexzwnbzevmrnvfnewpbrwyiqjzbvfdnlapipqjvovnbssryogchcarsjqufxzuizlsqc", "clqzatusku"

		`isContaining` is supposed to be prime factor that deteriorates the perfomance.
		*/
		pair<int, int> mi = { 0,2147483637 };
		while (!isContaining(dict_ans, dict_candi)) {
			if (r < s.size()) {
				dict_candi[s[r++]]++;
			}
			else
				break;

			// trivial optimization, still TLE : "cwwwfrveikcmukvklmwgcbigqxmewkragpwmgtqpgubagxmrlixnlhucfiidszgbpepvyhkgboiknubyezmqiiunqctlczmtdbqdidjlrtvenxeuysmgagwtipemqshttaxddiqwcmcrlgllzzrbfpuqeyewqmqlmpqrzhnbtpvgvgrugkynasfgtkdlwvzkkpbjwqnrfixcqqzydxofptlkdqwblvlxkojjewalgaowqnxvmlabeomieklshzrrnaauydhgdxdvmcryntcthqboapihozadcdzcghjleogrqzrfvtycjcqjrasfatieyigerprxfzqvzicubbyldrwwrpbtklxiveoovfmdecyfkdboeazjtxfkoieytdirjwffdriiwipglrurtvamvhwjpcilgseppjwudgebrujengwgbyuwisixvskdkqubarwfzaiqwrvjxtrztlxbehbbznekeyngrjnrmvjkmeukzllvzkwdszernidrirxacmtohcbtjvdiiodhzcmtbqkqaohlhgljseazgbv", "ryya"
			while (dict_ans[s[l]] == 0 && l < r)
				l++;

			bool isShrinked = false;
			while (isContaining(dict_ans, dict_candi)) {
				dict_candi[s[l++]]--;
				isShrinked = true;
			}

			if (isShrinked)
				mi = (mi.second < r - l + 1) ? mi : make_pair(l - 1, r - l + 1);
		}

		return mi.second == 2147483637 ? "" : s.substr(mi.first, mi.second);

	}
};


int main() {
	cout << Solution().minWindow("cwwwfrveikcmukvklmwgcbigqxmewkragpwmgtqpgubagxmrlixnlhucfiidszgbpepvyhkgboiknubyezmqiiunqctlczmtdbqdidjlrtvenxeuysmgagwtipemqshttaxddiqwcmcrlgllzzrbfpuqeyewqmqlmpqrzhnbtpvgvgrugkynasfgtkdlwvzkkpbjwqnrfixcqqzydxofptlkdqwblvlxkojjewalgaowqnxvmlabeomieklshzrrnaauydhgdxdvmcryntcthqboapihozadcdzcghjleogrqzrfvtycjcqjrasfatieyigerprxfzqvzicubbyldrwwrpbtklxiveoovfmdecyfkdboeazjtxfkoieytdirjwffdriiwipglrurtvamvhwjpcilgseppjwudgebrujengwgbyuwisixvskdkqubarwfzaiqwrvjxtrztlxbehbbznekeyngrjnrmvjkmeukzllvzkwdszernidrirxacmtohcbtjvdiiodhzcmtbqkqaohlhgljseazgbv"
		,"ryya") << endl;
	return 0;
}
```

---
### Spiral Matrix
https://leetcode.com/problems/spiral-matrix/


```c++
int d[2][4] = { {-1,0,1,0},{0,1,0,-1} };
// 단순히 북-동-남-서로 하면 되겠지 싶었는데 안된다. 현재 도는 방향을 기록하면서 가야한다.
// 북:0, 동:1, 남:2, 서:3
void dfs(int x, int y, int m, int n, int dir, vector<vector<int>> matrix, vector<vector<bool>>& visited, vector<int>& ret) {

	visited[x][y] = true;
	ret.push_back(matrix[x][y]);

	// 한번 dfs 진입하면 다른 방향으로 안돌기 위함.
	bool check = false;

	for (int i = 0; i < 4; i++) {
		if (check)
			break;

		int ndir = (dir + i) % 4;

		int nx = x + d[0][ndir], ny = y + d[1][ndir];
		if (nx < 0 || nx >= m || ny < 0 || ny >= n)
			continue;
		if (visited[nx][ny])
			continue;

		check = true;
		dfs(nx, ny, m, n, ndir, matrix, visited, ret);
	}
}

class Solution {
public:
	vector<int> spiralOrder(vector<vector<int>>& matrix) {
		vector<int> ret;

		if (matrix.empty())
			return ret;
		if (matrix[0].empty())
			return ret;

		int m = matrix.size();
		int n = matrix[0].size();
		vector<vector<bool>>visited(m, vector<bool>(n, false));
		dfs(0, 0, m, n, 1, matrix, visited, ret);
		return ret;

	}
};
```

---
